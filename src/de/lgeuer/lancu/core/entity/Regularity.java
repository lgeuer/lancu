/*
 * File: Reqularity.java
 * Author: Lars Geuer
 * Date: 24.4.2007
 */

package de.lgeuer.lancu.core.entity;

import java.util.Collection;
import java.util.Map;
import java.util.Observable;
import java.util.Observer;
import java.util.TreeMap;

import de.lgeuer.lancu.core.ItemAlreadyExistsException;
import de.lgeuer.lancu.core.LanguageViolationException;
import de.lgeuer.lancu.core.NoMatchingRuleException;
import de.lgeuer.lancu.core.RuleDoesNotApplyException;
import de.lgeuer.lancu.core.UnknownPhonemeStructureException;
import de.lgeuer.lancu.core.syntax.lancuregex.SyntaxException;
import de.lgeuer.lancu.util.id.IdFactory;
import de.lgeuer.lancu.util.id.UnknownIdException;


public class Regularity extends Observable implements LanguageItem, Observer,
	Comparable<Regularity> {

    private static final long serialVersionUID = -5807854485645127536L;

    private int id = IdFactory.VOID;

    private String name;

    private String oldName;

    private Language language;

    private InflectionState state;

    private IdFactory ruleIdFactory = new IdFactory();

    private UserDefinedTransactionComparator<Integer> comparator = new UserDefinedTransactionComparator<Integer>();

    private Map<Integer, AbstractRule> rules = new TreeMap<Integer, AbstractRule>(
	    comparator);

    public Regularity(String aName, InflectionState aState, Language aLanguage) {

	name = aName;
	oldName = aName;

	language = aLanguage;
	state = aState;

	comparator.register(rules);
    }

    @Override
    public void rollback() {

	name = oldName;
	setChanged();
	notifyObservers();
    }

    @Override
    public void commit() {

	oldName = name;
    }

    public void setId(int anId) {

	id = anId;
    }

    @Override
    public int getId() {

	return id;
    }

    public InflectionState getInflectionState() {

	return state;
    }

    public String getName() {

	return name;
    }

    public void setName(String aName) {

	name = aName;
	setChanged();
	notifyObservers();
    }

    public String applySequence(String aSequence, WordState wordState)
	    throws LanguageViolationException {

	String sequence = aSequence;
	for (int i = 0; i < ruleIdFactory.getLastId() + 1; i++) {

	    if (rules.containsKey(i)) {

		AbstractRule rule = rules.get(i);

		if (!wordState.hasBeenApplied(rule)) {

		    try {

			String returnSequence = rule.parse(sequence);
			wordState.addAppliedRule(rule);
			return returnSequence;
		    } catch (RuleDoesNotApplyException ex) {

			//try next rule
		    }
		}
	    }
	}

	throw new NoMatchingRuleException("No rule mached '" + aSequence
		+ "' in reguarity " + name + " of " + state.getName());
    }

    public int addRule(String aRule) throws ItemAlreadyExistsException,
	    SyntaxException, UnknownPhonemeStructureException {

	AbstractRule rule = AbstractRule.newInstance(aRule, language);

	if (getRules().contains(rule)) {

	    throw new ItemAlreadyExistsException("Rule already exists: " + rule);

	}

	rule.addObserver(this);
	setChanged();
	notifyObservers();

	return addRule(rule);
    }

    /**
     * Should only be used for rules generated by another inflectionState
     */
    public int addRule(AbstractRule rule) {

	rule.setId(ruleIdFactory.getId());

	rules.put(rule.getId(), rule);
	comparator.add(rule.getId());

	rule.addObserver(this);
	setChanged();
	notifyObservers();

	return rule.getId();
    }

    public void removeRule(AbstractRule aRule) {

	int ruleId = aRule.getId();

	rules.remove(ruleId);
	comparator.remove(ruleId);

	aRule.deleteObserver(this);
	setChanged();
	notifyObservers();
    }

    public void moveUp(AbstractRule aRule) throws UnknownIdException {

	int ruleId = aRule.getId();

	if (rules.containsKey(ruleId)) {

	    comparator.moveUp(ruleId);

	    setChanged();
	    notifyObservers();
	} else {

	    throw new UnknownIdException("Unknown rule: " + ruleId, ruleId);
	}

    }

    public void moveDown(AbstractRule aRule) throws UnknownIdException {

	int ruleId = aRule.getId();

	if (rules.containsKey(ruleId)) {

	    comparator.moveDown(ruleId);

	    setChanged();
	    notifyObservers();
	} else {

	    throw new UnknownIdException("Unknown rule: " + ruleId, ruleId);
	}
    }

    public AbstractRule getRule(int ruleId) throws UnknownIdException {

	if (rules.containsKey(ruleId)) {

	    return rules.get(ruleId);
	}

	throw new UnknownIdException("Unknown rule: " + ruleId, ruleId);
    }

    public Collection<AbstractRule> getRules() {

	return rules.values();
    }

    @Override
    public void update(Observable o, Object obj) {

	setChanged();
	notifyObservers();
    }

    public boolean contains(AbstractRule rule) {

	return getRules().contains(rule);
    }

    @Override
    public boolean equals(Object o) {

	if (!(o instanceof Regularity)) {

	    return false;
	}

	Regularity otherRegularity = (Regularity) o;

	return getName().equals(otherRegularity.getName())
		&& this.getInflectionState() == otherRegularity
			.getInflectionState()
		&& this.language == otherRegularity.language;
    }

    @Override
    public int compareTo(Regularity r) {

	return getName().compareTo(r.getName());
    }

    @Override
    public String toString() {

	return getName();
    }
}